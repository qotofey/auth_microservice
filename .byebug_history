c
result.user.id
result.user
result.failure?
result
c
meta = JwtEncoder.decode(data[:token])
JwtEncoder.decode(data[:token])
c
data[:token]
data.token
data.tokeen
data
data['uuid']
c
result = env['HTTP_AUTHORIZATION'].match(auth_pattern)
c
result = env['HTTP_AUTHORIZATION'].match(auth_pattern)
c
env['HTTP_AUTHORIZATION']
c
env['HTTP_AUTHORIZATION']
env
c
с
values[:confirmed_password]
values[:password]
values[::password]
values
c
result.user.id
result.user_id
result.user
result
c
Settings.app.secret.to_s
Settings.app.secret
result.session.uuid
JwtEncoder.encode(uuid: result.session.uuid)
c
с
result.session.user_id
result.session
result.user_id
result.user
result
result.user
result.values
result.value
c
ErrorSerializer.from_message result.errors
result.errors
result
c
ErrorSerializer.from_message(result)
ErrorSerializer.from_model(result)
result.errors
result
result = UserSession::CreateService.call(*contract.to_h.values)
c
с
result.errors
result.failure?
result.values
result = UserSession::CreateService.call(*contract.to_h.values)
result
c
result.
result.password
result.email
result
result.user
result.use
result.values
result
result.values
result.value
result.failure?
result.value!
result.values!
result = UserSession::CreateService.call(*contract.to_h.values)
UserSession::CreateService.call(*contract.to_h.values)
contract.to_h.values
exit
contract.to_h.values
*contract.to_h.values
UserSession::CreateService.call(*contract.to_h.values)
c
error
error[:source] = { pointer: "/#{message.path.join('/')}" }
error = build_error(message.text)
c
errors..pathe
errors..path
errors.path.path
errors.path
errors
error
error[:source] = { pointer: "/#{error.path.join('/')}" }
error[:source] = { pointer: "/#{path.join('/')}" }
error = build_error(error.text)
error = build_error(message.text)
exit
errors.path
errors
messages
errors.first
errors
key
exit
contract.errors.first.messages
contract.errors.first
contract.errors.map { |k,v| puts k,v }
contract.errors.first
contract.errors
ErrorSerializer.from_model(contract.errors)
ErrorSerializer.from_model(contract)
contract.errors
contract
c
exit
p.errors.map { |item| "/#{item.path.join('/')}" }
p.errors.map { |item| "/#{item.path.join('/')" }
p.errors.map { |item| "/#{item.path.join('/')}"
p.errors.map { |item| "/#{item.path.join('/')}
p.errors.map { |k,v| {k => v} }
p.errors.map { |k,v| puts k,v }
p.errors.map { |k| puts k }
p.errors
p.values
p.value?
p = UserRegistrationContract.new.call(params)
UserRegistrationContract.new.call(params)
params
pararms
paarms
exit
r.status
r
r.headers
r.headers['Content-Type'] = 'application/json'
r.headers.class
r.headers
r.headers['Content-Type']
r.headers['Content-Type]
r.headers
r
rr
r.finish
r =Roda::RodaResponse.new
Roda::RodaResponse.new.finish
Roda::RodaResponse.finish
Roda::RodaResponse.new
Roda::RodaResponse.new.to_s
Roda::RodaResponse.new.to_a
Roda::RodaResponse.new
Roda::RodaResponse
App::RodaResponse
RodaResponse
response.headers.class
response.headers
response
Rack::Headers.new.class
Rack::Headers.new
Rack::Headers
c
response.write(123)
response
response.write(123)
response
response.write('1')
response.finish
response.to_a
response
30 * 108 * 20
30 * 108
1565000.0 / 12 / 15
1565000.0 / 12
1565000 / 12
118 * 31
response
response.[]
response[]
response.length
response.finish
response
response.body = '{}'
response
response.to_a
response.status = 401
response = Rack::Response.new()
Rack::Response.new()
Rack::Response.new(env)
Rack::Request.new(env).params
Rack::QueryParser.new(env)
Rack::QueryParser.new()
Rack::Rack::QueryParser.new()
Rack::Headers.new()
Rack::Headers.new(env)
Oj.load(Rack::Request.new(env).headers)
Oj.load(Rack::Request.new(env).body)
Oj.dump(Rack::Request.new(env).body)
Oj.load(Rack::Request.new(env).body)
Rack::Request.new(env).body.as_json
Rack::Request.new(env).body.to_s
c
Rack::Request.new(env).body
env.pararms
Rack::Request.new(env).content_type
Rack::Request.new(env).content_tpe
Rack::Request.new(env).content_tpee
Rack::Request.new(env).content
Rack::Request.new(env).headers
Rack::Request.new(env).params
Rack::Request.new(env)
env.to_param
env.param
env.params
env
c
env['QUERY_STRING']
env
c
user_params = UserRegistrationContract.new.call(params)
params
c
r.body.read
r.body
r.data
c
r.headers
Oj.dump body
Oj.load body
body
body = r.body.read
c
exit
body = r.body.read
JSON.parse r.body.read
c
r.body.read
JSON.parse r.body.read
r.body.read.as_json
r.body.read.to_json
Oj.load(r.body.read.to_json)
Oj.load(r.body.read)
Oj.load r.body.read
Oj.dump r.body.read
r.body.read
r.body
exit
r.body.read
r.content_type
r.content
r.body
r.body['data']
